# 浏览器页面渲染过程

![image.png](https://camo.githubusercontent.com/e1a27c720a992c425ab5a2d26e0707445d0220abd8e6b87af88f6b7b09aca552/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032322f706e672f38393432302f313636363632353031373838332d34663731336238382d666630612d346366382d393439652d6536646137646536346231652e706e6723636c69656e7449643d7566643561663362622d333563332d342663726f703d302663726f703d302663726f703d312663726f703d312666726f6d3d7061737465266865696768743d3934362669643d753565663535383231266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d696d6167652e706e67266f726967696e4865696768743d31383932266f726967696e57696474683d33323036266f726967696e616c547970653d62696e61727926726174696f3d3126726f746174696f6e3d302673686f775469746c653d66616c73652673697a653d3834393133267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7530356566383138622d633133382d343633312d623862642d6565303232626531316435267469746c653d2677696474683d31363033)

## 前言

在面试的时候，经常会遇到的两道道经典的面试题：

**1. 从输入URL到页面展示，这中间发生了什么？**
**2. 如何优化网页加载速度？**

常规的回答中总会有一条：

**把 css 文件放在页面顶部，把 js 文件放在页面底部。**

那么，为什么要把 js 文件放在页面的最底部呢？

我们先来看下这段代码：

```
<!DOCTYPE html>
<html lang="zh">
  <head>
    <title>Hi</title>
    <script>
        console.log("Howdy ~");
    </script>
    <script src="https://unpkg.com/vue@3.2.41/dist/vue.global.js"></script>
    <script src="https://unpkg.com/vue-router@4.1.5/dist/vue-router.global.js"></script>
  </head>
  <body>
    Hello 👋🏻 ~
  </body>
</html>
```

他的执行顺序是：

* 在控制台打印：`Howdy ~`
* 请求并执行 **vue.global.js**
* 请求并执行 **vue-router.global.js**
* 在页面中展示：`Hello 👋🏻 ~`
* 触发 [DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/API/Window/DOMContentLoaded_event) 事件

![image.png](https://camo.githubusercontent.com/27e4a530fe05e57972f328181105aed0f0569618a7586e3817ec81ed627c3339/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032322f706e672f38393432302f313636363531303736383635302d38363334363364312d303034372d346636352d623035332d6239323237373438376133382e706e6723636c69656e7449643d7535646338656563382d623564632d342663726f703d302663726f703d302663726f703d312663726f703d31266572726f724d6573736167653d756e6b6e6f776e2532306572726f722666726f6d3d7061737465266865696768743d3531352669643d5477506842266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d696d6167652e706e67266f726967696e4865696768743d31303330266f726967696e57696474683d32343430266f726967696e616c547970653d62696e61727926726174696f3d3126726f746174696f6e3d302673686f775469746c653d747275652673697a653d3432303237267374617475733d6572726f72267374796c653d6e6f6e65267461736b49643d7539356663623735642d353938352d343233312d623936352d3434653961633761646432267469746c653d2533437363726970742533452532302545352538412541302545382542442542442545392538302542422545382542452539312677696474683d31323230)

浏览器的解析规则是：如果遇到 `script` 标签，则暂停构建 `DOM`，转而开始执行 `script` 标签，如果是[外部 script](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-src)，那么浏览器还需要一直等待其「下载」并「执行」后，再继续解析后面的 HTML。

如果请求并执行「**vue.global.js**」需要 3 秒，「**vue-router.global.js**」需要 2 秒，那么页面中的 `Hello 👋🏻 ~`，则至少需要 5 秒以上才会展示出来。

可以看到，script 标签会阻塞浏览器解析 HTML，如果把 `script` 都放在 `head` 中，在网络不佳的情况下，就会导致页面长期处于白屏状态。

在很久以前，一般都是将这些外联脚本，放在 `body` 标签的最后面，确保先解析展示 `body` 中的内容，然后再一个个请求执行这些外联脚本。

那有没有其他更优雅的解决方案呢？

答案是肯定的，现在 `script` 标签新增了 2 个属性：`defer` 和 `async`，就是为了解决此类问题，提升页面性能的。

## `<script defer>`
先看一下 MDN 上的解释：

这个布尔属性被设定用来通知浏览器该脚本将在文档完成解析后，触发 DOMContentLoaded 事件前执行。
有 defer 属性的脚本会阻止 DOMContentLoaded 事件，直到脚本被加载并且解析完成。

文档是直接总结了他的特性，我们先看看下面的代码，展开说说细节，加深一下理解。

```
<!DOCTYPE html>
<html lang="zh">
  <head>
    <title>Hi</title>
    <script>
      console.log("Howdy ~");
    </script>
    <script defer src="https://unpkg.com/vue@3.2.41/dist/vue.global.js"></script>
    <script defer src="https://unpkg.com/vue-router@4.1.5/dist/vue-router.global.js"></script>
  </head>
  <body>
    Hello 👋🏻 ~
  </body>
</html>
```

他的执行顺序是：

* 在控制台打印：`Howdy ~`
* 在页面中展示：`Hello 👋🏻 ~`
* 请求并执行 **vue.global.js**
* 请求并执行 **vue-router.global.js**
* 触发 [DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/API/Window/DOMContentLoaded_event) 事件

![image.png](https://camo.githubusercontent.com/ccdd8e66a3e82799a3599d1080dffe3e3fcc80df7caa4cf514ef342b1be63b86/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032322f706e672f38393432302f313636363531303835363436322d39636334373163302d616366322d346666622d383939612d3164643831666131666361322e706e6723636c69656e7449643d7535646338656563382d623564632d342663726f703d302663726f703d302663726f703d312663726f703d31266572726f724d6573736167653d756e6b6e6f776e2532306572726f722666726f6d3d7061737465266865696768743d3531352669643d4f71577435266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d696d6167652e706e67266f726967696e4865696768743d31303330266f726967696e57696474683d32343430266f726967696e616c547970653d62696e61727926726174696f3d3126726f746174696f6e3d302673686f775469746c653d747275652673697a653d3431393835267374617475733d6572726f72267374796c653d6e6f6e65267461736b49643d7566633539346362622d343661332d343433642d613337652d6138333662353462393666267469746c653d25334373637269707425323064656665722532302532462533452532302545352538412541302545382542442542442545392538302542422545382542452539312677696474683d31323230)

如果在 `script` 标签上设置了 `defer` 属性，那么在浏览器解析到这里时，会默默的在后台开始下载此脚本，并继续解析后面的 HTML，并不会阻塞解析操作。

等到 HTML 解析完成之后，浏览器会立即执行后台下载的脚本，脚本执行完成之后，才会触发 `DOMContentLoaded` 事件。

看起来还是蛮好理解的吧？咱们再来讨论 2 个小细节：

**Q1：** 如果 HTML 解析完成之后，设置了 `defer` 属性的脚本还没下载完成，会怎样？ **A1：** 浏览器会等脚本下载完成之后，再执行此脚本，执行完成之后，再触发 `DOMContentLoaded` 事件。

**Q2：** 如果有多个设置了 `defer` 属性的脚本，那浏览器会如何处理？ **A2：** 浏览器会并行的在后台下载这些脚本，等 HTML 解析完成，并且所有脚本下载完成之后，再按照他们在 HTML 中出现的相对顺序执行，等所有脚本执行完成之后，再触发 `DOMContentLoaded` 事件。

**最佳实践：**

建议所有的外联脚本都默认设置此属性，因为他不会阻塞 HTML 解析，可以并行下载 JavaScript 资源，还可以按照他们在 HTML 中的相对顺序执行，确保有依赖关系的脚本运行时，不会缺少依赖。

在 SPA 的应用中，可以考虑把所有的 `script` 标签加上 `defer` 属性，并且放到 `body` 的最后面。在现代浏览器中，可以并行下载提升速度，也可以确保在老浏览器中，不阻塞浏览器解析 HTML，起到降级的作用。

**注意：**

* `defer` 属性仅适用于外部脚本，如果 `script` 脚本没有 `src`，则会忽略 `defer` 特性。
* `defer` 属性对模块脚本（[<script type='module'></script>](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-type)）无效，因为模块脚本就是以 `defer` 的形式加载的。

## `<script async>`
按照惯例，先看一下 MDN 上的解释：

对于普通脚本，如果存在 async 属性，那么普通脚本会被并行请求，并尽快解析和执行。
对于模块脚本，如果存在 async 属性，那么脚本及其所有依赖都会在延缓队列中执行，因此它们会被并行请求，并尽快解析和执行。
该属性能够消除解析阻塞的 Javascript。
解析阻塞的 Javascript 会导致浏览器必须加载并且执行脚本，之后才能继续解析。

感觉这段描述的已经蛮清晰了，不过咱们还是先看看下面的代码，展开说说细节，加深一下理解。

```
<!DOCTYPE html>
<html lang="zh">
  <head>
    <title>Hi</title>
    <script>
      console.log("Howdy ~");
    </script>
    <script async src="https://google-analytics.com/analytics.js"></script>
    <script async src="https://ads.google.cn/ad.js"></script>
  </head>
  <body>
    Hello 👋🏻 ~
  </body>
</html>
```

他的执行顺序是：

* 在控制台打印：`Howdy ~`
* 并行请求 **analytics.js** 和 **ad.js**
* 在页面中展示：`Hello 👋🏻 ~`
* 根据网络的实际情况，以下几项会无序执行
  
  * 执行 **analytics.js** （下载完后，立即执行）
  * 执行 **ad.js** （下载完后，立即执行）
  * 触发 [DOMContentLoaded](https://developer.mozilla.org/en-US/docs/Web/API/Window/DOMContentLoaded_event) 事件（可能在在上面 2 个脚本之前，之间，之后触发）

![image.png](https://camo.githubusercontent.com/ea0281979ed9e515cde2433832b55131ae62862bf82544e5437cafb962bcea30/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032322f706e672f38393432302f313636363531303832343438362d37653436626364352d336639652d343561612d616336632d6163386161306635623837662e706e6723636c69656e7449643d7535646338656563382d623564632d342663726f703d302663726f703d302663726f703d312663726f703d31266572726f724d6573736167653d756e6b6e6f776e2532306572726f722666726f6d3d7061737465266865696768743d3531352669643d4f7078345a266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d696d6167652e706e67266f726967696e4865696768743d31303330266f726967696e57696474683d32343430266f726967696e616c547970653d62696e61727926726174696f3d3126726f746174696f6e3d302673686f775469746c653d747275652673697a653d3432303239267374617475733d6572726f72267374796c653d6e6f6e65267461736b49643d7537653161626236332d363063372d346466312d613761372d6135616366396661316638267469746c653d2533437363726970742532306173796e632532302532462533452532302545352538412541302545382542442542442545392538302542422545382542452539312677696474683d31323230) 浏览器在解析到带有 `async` 属性的 `script` 标签时，也不会阻塞页面，同样是在后台默默下载此脚本。当他下载完后，浏览器会暂停解析 HTML，立马执行此脚本。

看起来还是蛮好理解的吧？咱们再来讨论 2 个小细节：

**Q1：** 如果设置了 `async` 属性的 `script` 下载完之后，浏览器还没解析完 HTML，会怎样？ **A1：** 浏览器会暂停解析 HTML，立马执行此脚本，等执行完之后，再继续解析 HTML。

**Q2：** 如果有多个 `async` 属性的 `script` 标签，那等他们下载完成之后，会按照代码顺序执行吗？ **A2：** 不会。执行顺序是：谁先下载完成，谁先执行。`async` 的特点是「完全独立」，不依赖其他内容。

**最佳实践：**

当我们的项目，需要集成其他独立的第三方库时，可以使用此属性，他们不依赖我们，我们也不依赖于他们。 通过设置此属性，让浏览器异步下载并执行他，是个不错的优化方案。

**注意：**

* `async` 特性仅适用于外部脚本，如果 `script` 脚本没有 `src`，则会忽略 `async` 特性。

## 总结
### `defer`
* 不阻塞浏览器解析 HTML，等解析完 HTML 之后，才会执行 `script`。
* 会并行下载 JavaScript 资源。
* 会按照 HTML 中的相对顺序执行脚本。
* 会在脚本下载并执行完成之后，才会触发 `DOMContentLoaded` 事件。
* 在脚本执行过程中，一定可以获取到 HTML 中已有的元素。
* `defer` 属性对[模块脚本](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-type)无效。
* 适用于：所有外部脚本（通过 `src` 引用的 `script`）。

### `async`
* 不阻塞浏览器解析 HTML，但是 `script` 下载完成后，会立即中断浏览器解析 HTML，并执行此 `script`。
* 会并行下载 JavaScript 资源。
* 互相独立，谁先下载完，谁先执行，没有固定的先后顺序，不可控。
* 由于没有确定的执行时机，所以在脚本里面可能会获取不到 HTML 中已有的元素。
* `DOMContentLoaded` 事件和 `script` 脚本无相关性，无法确定他们的先后顺序。
* 适用于：独立的第三方脚本。

另外：`async` 和 `defer` 之间最大的区别在于它们的执行时机。

### One More Thing
你有没有想过，如果一个 `script` 标签同时设置 `defer` 和 `async`，浏览器会如何处理？

先说结论：从表现形式上来说，`async` 的优先级比 `defer` 高，也就是如果同时存在这 2 个属性，那么浏览器将会以 `async` 的特性去加载此脚本。

这主要分 2 种情况：

如果是「普通脚本」，浏览器会优先判断`async`属性是否存在，如果存在，则以`async`特性去加载此脚本，如果不存在，再去判断是否存在`defer`属性。

如果是「[模块脚本](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script#attr-type)」，浏览器会判断`async`属性是否存在：

* 如果存在，浏览器会并行下载此模块和他的所有依赖模块，等全部下载完成之后，会立刻执行此脚本。
* 如果不存在，浏览器也会并行下载此模块和他的所有依赖模块，然后等浏览器解析完 HTML 之后，再执行此脚本。
* 另外需要注意的是：在模块脚本上设置 `defer` 属性是无效的。

### 一图胜千言
最后，用一张图概括一下这两个属性的加载模式吧： ![image.png](https://camo.githubusercontent.com/1fbd4b6b55c6c2f07ab12bc79cdc89b295a4ce942a4f75fac94f65cd24aac6e4/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032322f706e672f38393432302f313636353832313630363430302d65626235623532302d353363322d343961632d623962392d3839643862363432303237352e706e6723636c69656e7449643d7566653266643564392d383530342d342663726f703d302663726f703d302663726f703d312663726f703d31266572726f724d6573736167653d756e6b6e6f776e2532306572726f722666726f6d3d7061737465266865696768743d3531312669643d753466626466313930266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d696d6167652e706e67266f726967696e4865696768743d31303232266f726967696e57696474683d33333630266f726967696e616c547970653d62696e61727926726174696f3d3126726f746174696f6e3d302673686f775469746c653d747275652673697a653d313736383234267374617475733d6572726f72267374796c653d6e6f6e65267461736b49643d7532663363613830632d613739302d346435612d623930342d3664376466316635363064267469746c653d64656665722532302545352539322538432532306173796e632532302545372539412538342545352538412541302545382542442542442545362541382541312545352542432538462677696474683d31363830)

## 思考题 🤔
* 为什么浏览器在解析到普通的 script 标签时，必须先执行他？
  * 可以先对页面进行一些设置，比如根据浏览器的形态改变一些全局变量
  * 对于数据采集或者上报可以更提前
  * 让页面可以更多的多样化，如果js只能滞后执行，那么页面预处理就不能通过js来处理了
* 普通的 script 标签会阻塞浏览器解析 HTML，这会导致什么问题？
  * 如果加载的 js 代码较大，且js本身执行时间过长，都会导致页面性能变差，延长FCP和LCP时间
  * 导致 js 代码在加载过程中获取不到 页面的 DOM

## 参考

* https://github.com/mrlmx/blogs/issues/4
* https://javascript.info/script-async-defer
* https://www.growingwiththeweb.com/2014/02/async-vs-defer-attributes.html
* https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script
* https://html.spec.whatwg.org/multipage/scripting.html

