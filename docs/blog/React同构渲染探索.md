# React 同构渲染探索

## 背景

组内 `c端` 前端框架体系的核心是 `Next.js` ，但基于其源码直接改写的方式，造成了框架及其周边第三方库的升级困难问题，这个问题持续了 4 年，2 年前重构框架代码的时候就已经抛出这个问题，但是因为已经大批量用于生产项目，再加上成本问题，最终还是没有避免改源码的这个问题，但也减少了一些对源码的直接改动，只是在源码上进行了一些增量改动，直到最近才有比较多的时间再来梳理这一个问题。

对框架源代码进行改动的重要原因之一就是：高并发会导致 nodejs 服务性能变差，响应变慢，甚至因为 有段时间发现 nextjs 框架有内存泄露的问题，导致nodejs服务不断重启。

于是就对源码扩展了 `动态降级` 的功能，可以根据服务端性能情况进行动态分配走 `ssr渲染` 还是渲染已打包好的静态 html 资源。

前段时间发现 `动态降级率` 暴涨，对其进行了压测分析，分析了其原因以及优化的方向。再加上打算升级框架，并脱离直接修改源码的方案，于是重新再去了解了一下nextjs，对 React 如何实现同构渲染，以及我们工作中一般会怎么去选择渲染模式进行了分析和总结。

## 渲染模式

我们所说的渲染模式一般来说可以分为两种：服务端渲染（SSR）和客户端渲染（CSR），后面就直接都用缩写。

### SSR 和 CSR 的区别

>> 从性能体验来看：

SSR 指的是当客户端收到 http 相应时，就已经可以看到页面上的所有的内容，一般来说响应时间会比较短，正常网速下，页面显示时间在0.5～3秒，用户等待时间少。

CSR 指的是当客户端收到 http 相应时，页面仍然是白屏，需要等待一段时间加载完成关键资源，再去通过代码渲染页面内容，一般来说，就算是正常网速，页面首次显示页面时间也比较长，与关键资源的体积大小有关，一般来说会比 SSR 渲染时间慢个几倍都比较正常。

分析：
- 每次访问页面都是 SSR，体验上也不一定好，比如在一个应用有多个页面时，每次切换页面都卡顿0.5～3秒，用户仍然会有卡顿感。
- CSR 虽然首屏访问时间较长，但因为首次资源都价值完了，所以每次切换页面都很快，用户切换页面不会有卡顿感
- 因为上面两点原因，开发者们就想到了另外一种渲染模式 ———— 同构渲染，也就是让应用可以有 SSR 的首屏体验，有 CSR 的页面切换体验

>> 从SEO上来看：

SSR 因为直接返回的html带有内容，对 SEO 友好，可以让更多的用户通过搜索引擎搜索到应用。

CSR 一般来说，因为只会返回空壳 html，对 SEO 不太友好，只能在页面头部加一些特定的 meta 标签来做一些简单的 SEO。

分析：如果页面需要 SEO，需要首先考虑 SSR

>> 从实现上来看：

SSR 是在服务收到 http 请求时，把渲染好的页面内容通过 html 直接返回给浏览器进行显示，再去加载页面需要的JS代码。

CSR 是在服务收到 http 请求时，先返回给浏览器一个空壳 html，里面只需要有少许代码，比如一个loading，让用户自动应用正在加载中，以及加载一些关键资源的 script 或者 link 等标签，当浏览器渲染完成这一段空壳 html 后，再去下载 JS 代码，下载完js代码后，再执行JS代码，在执行渲染页面内容的代码时，才会去准备渲染页面内容。


## Next.js 的渲染方案

## 我们公司C端的渲染方案

## 最佳实践

## 最后